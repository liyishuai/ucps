(* generated by Ott 0.27, locally-nameless lngen from: ucps.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition x := var. (*r variables *)

Inductive e : Set :=  (*r expressions *)
 | e_var_b : nat -> e
 | e_var_f : x -> e
 | e_lam : e -> e
 | e_app : e -> e -> e
 | e_halt : e -> e.

Definition G : Set := list x.

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_e_wrt_e_rec (k:nat) (e_6:e) (e__7:e) {struct e__7}: e :=
  match e__7 with
  | (e_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_var_b nat
        | inleft (right _) => e_6
        | inright _ => e_var_b (nat - 1)
      end
  | (e_var_f x5) => e_var_f x5
  | (e_lam e5) => e_lam (open_e_wrt_e_rec (S k) e_6 e5)
  | (e_app e1 e2) => e_app (open_e_wrt_e_rec k e_6 e1) (open_e_wrt_e_rec k e_6 e2)
  | (e_halt e5) => e_halt (open_e_wrt_e_rec k e_6 e5)
end.

Definition open_e_wrt_e e_6 e__7 := open_e_wrt_e_rec 0 e__7 e_6.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_e *)
Inductive lc_e : e -> Prop :=    (* defn lc_e *)
 | lc_e_var_f : forall (x5:x),
     (lc_e (e_var_f x5))
 | lc_e_lam : forall (e5:e),
      ( forall x5 , lc_e  ( open_e_wrt_e e5 (e_var_f x5) )  )  ->
     (lc_e (e_lam e5))
 | lc_e_app : forall (e1 e2:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_e (e_app e1 e2))
 | lc_e_halt : forall (e5:e),
     (lc_e e5) ->
     (lc_e (e_halt e5)).
(** free variables *)
Fixpoint fv_e (e_6:e) : vars :=
  match e_6 with
  | (e_var_b nat) => {}
  | (e_var_f x5) => {{x5}}
  | (e_lam e5) => (fv_e e5)
  | (e_app e1 e2) => (fv_e e1) \u (fv_e e2)
  | (e_halt e5) => (fv_e e5)
end.

(** substitutions *)
Fixpoint subst_e (e_6:e) (x_6:x) (e__7:e) {struct e__7} : e :=
  match e__7 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x5) => (if eq_var x5 x_6 then e_6 else (e_var_f x5))
  | (e_lam e5) => e_lam (subst_e e_6 x_6 e5)
  | (e_app e1 e2) => e_app (subst_e e_6 x_6 e1) (subst_e e_6 x_6 e2)
  | (e_halt e5) => e_halt (subst_e e_6 x_6 e5)
end.


(** definitions *)

(* defns L *)
Inductive L_exp : G -> e -> Prop :=    (* defn L_exp *)
 | L_exp_var : forall (G5:G) (x5:x),
      In  x5   G5  ->
     L_exp G5 (e_var_f x5)
 | L_exp_app : forall (G5:G) (e1 e2:e),
     L_exp G5 e1 ->
     L_exp G5 e2 ->
     L_exp G5 (e_app e1 e2)
 | L_exp_lam : forall (L:vars) (G5:G) (e5:e),
      ( forall x5 , x5 \notin  L  -> L_exp  ( x5  ::  G5 )   ( open_e_wrt_e e5 (e_var_f x5) )  )  ->
     L_exp G5 (e_lam e5)
with eq : G -> e -> e -> Prop :=    (* defn eq *)
 | L_eq_id : forall (G5:G) (e5:e),
     L_exp G5 e5 ->
     eq G5 e5 e5
 | L_eq_comm : forall (G5:G) (e' e5:e),
     eq G5 e5 e' ->
     eq G5 e' e5
 | L_eq_trans : forall (G5:G) (e5 e'' e':e),
     eq G5 e5 e' ->
     eq G5 e' e'' ->
     eq G5 e5 e''
 | L_eq_app : forall (G5:G) (e1 e2 e1' e2':e),
     eq G5 e1 e1' ->
     eq G5 e2 e2' ->
     eq G5 (e_app e1 e2) (e_app e1' e2')
 | L_eq_lam : forall (L:vars) (G5:G) (e5 e':e),
      ( forall x5 , x5 \notin  L  -> eq  ( x5  ::  G5 )   ( open_e_wrt_e e5 (e_var_f x5) )   ( open_e_wrt_e e' (e_var_f x5) )  )  ->
     eq G5 (e_lam e5) (e_lam e')
 | L_eq_abs : forall (L:vars) (G5:G) (e2 e1:e),
      ( forall x5 , x5 \notin  L  -> L_exp  ( x5  ::  G5 )   ( open_e_wrt_e e2 (e_var_f x5) )  )  ->
     L_exp G5 e1 ->
     eq G5 (e_app  ( (e_lam e2) )  e1)  (open_e_wrt_e  e2   e1 ) .

(* defns K *)
Inductive K_exp : G -> e -> Prop :=    (* defn K_exp *)
 | K_exp_var : forall (G5:G) (x5:x),
      In  x5   G5  ->
     K_exp G5 (e_var_f x5)
 | K_exp_app : forall (G5:G) (e1 e2:e),
     K_exp G5 e1 ->
     K_exp G5 e2 ->
     K_exp G5 (e_app e1 e2)
 | K_exp_lam : forall (L:vars) (G5:G) (e5:e),
      ( forall x5 , x5 \notin  L  -> K_exp  ( x5  ::  G5 )   ( open_e_wrt_e e5 (e_var_f x5) )  )  ->
     K_exp G5 (e_lam e5)
 | K_exp_halt : forall (G5:G) (e5:e),
     K_exp G5 e5 ->
     K_exp G5 (e_halt e5)
with step : G -> e -> e -> Prop :=    (* defn step *)
 | K_step_abs : forall (L:vars) (G5:G) (e2 e1:e),
      ( forall x5 , x5 \notin  L  -> K_exp  ( x5  ::  G5 )   ( open_e_wrt_e e2 (e_var_f x5) )  )  ->
     K_exp G5 e1 ->
     step G5 (e_app  ( (e_lam e2) )  e1)  (open_e_wrt_e  e2   e1 ) .


(** infrastructure *)
Hint Constructors L_exp eq K_exp step lc_e.


